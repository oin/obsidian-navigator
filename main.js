/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NavigatorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  commonPrefixSeparators: "-:_+ /,;?!",
  commonPrefixExtendSearch: true,
  todayDateFormat: "YYYY-MM-DD",
  useSameExtension: true,
  commandPatterns: []
};

// src/util.ts
function multisplit(str, separators) {
  if (!separators.length)
    return str.split("");
  let sep = separators[0];
  for (let i = 1; i < separators.length; ++i) {
    str = str.split(separators[i]).join(sep);
  }
  return str.split(sep);
}
function longestCommonPrefixWithSeparators(reference, others, separators) {
  if (!others.length)
    return "";
  let pieces = multisplit(reference, separators.split(""));
  let lastPrefix = "";
  for (let i = 0; i < pieces.length; ++i) {
    let prefix = lastPrefix + (i == 0 ? "" : reference[lastPrefix.length]) + pieces[i];
    if (others.filter((str) => str !== prefix && str.startsWith(prefix)).length == 0) {
      return lastPrefix;
    }
    lastPrefix = prefix;
  }
  return reference;
}
function indexOfPrevNextWithCommonPrefix(files, current, length, settings, isNext) {
  let strFiles = files.map((f) => f.basename);
  let reference = files[current].basename;
  let prefix = longestCommonPrefixWithSeparators(reference, strFiles, settings.commonPrefixSeparators);
  if (!prefix.length) {
    if (settings.commonPrefixExtendSearch && (!isNext && current > 0 || isNext && current + 1 < length)) {
      return isNext ? current + 1 : current - 1;
    } else {
      return length;
    }
  }
  let filterFn = (file) => file.basename.startsWith(prefix);
  let idx = isNext ? files.map(filterFn).lastIndexOf(true) : files.findIndex(filterFn);
  if (idx === current && settings.commonPrefixExtendSearch && (!isNext && current > 0 || isNext && current + 1 < length)) {
    return isNext ? current + 1 : current - 1;
  }
  return idx;
}
function todayStr(format) {
  if (!format) {
    format = "YYYY-MM-DD";
  }
  return window.moment(/* @__PURE__ */ new Date()).format(format);
}
function filesWithCommandPattern(files, pattern, dateFormat) {
  const decomposedPattern = pattern.split("#");
  if (decomposedPattern.length < 2)
    return [];
  const patternPrefix = decomposedPattern[0];
  const patternSuffix = decomposedPattern[1];
  return files.filter((file) => {
    const m = window.moment(file.path, dateFormat);
    if (!m.isValid())
      return false;
    const unused = m.parsingFlags().unusedInput;
    if (unused.length != 2)
      return false;
    const [prefix, suffix] = unused;
    return prefix.endsWith(patternPrefix) && suffix == patternSuffix;
  });
}
function commandPatternExpand(pattern, settings) {
  const decomposedPattern = pattern.split("#");
  if (decomposedPattern.length < 2)
    return pattern;
  const patternPrefix = decomposedPattern[0];
  const patternSuffix = decomposedPattern[1];
  return patternPrefix + todayStr(settings.todayDateFormat) + patternSuffix;
}

// src/movement_methods.ts
var MOVEMENT_METHODS = [
  {
    id: "next",
    whichString: "next",
    fn: (files, current, length, settings) => current + 1
  },
  {
    id: "previous",
    whichString: "previous",
    fn: (files, current, length, settings) => current - 1
  },
  {
    id: "first",
    whichString: "first",
    fn: (files, current, length, settings) => 0
  },
  {
    id: "last",
    whichString: "last",
    fn: (files, current, length, settings) => length - 1
  },
  {
    id: "today-first",
    whichString: "first with today in name",
    fn: (files, current, length, settings) => {
      let todaystr = window.moment(/* @__PURE__ */ new Date()).format(settings.todayDateFormat);
      return files.findIndex((file) => file.basename.includes(todaystr));
    }
  },
  {
    id: "today-last",
    whichString: "last with today in name",
    fn: (files, current, length, settings) => {
      let todaystr = window.moment(/* @__PURE__ */ new Date()).format(settings.todayDateFormat);
      return files.map((file) => file.basename.includes(todaystr)).lastIndexOf(true);
    }
  },
  {
    id: "commonprefix-first",
    whichString: "first with same prefix",
    fn: (files, current, length, settings) => indexOfPrevNextWithCommonPrefix(files, current, length, settings, false)
  },
  {
    id: "commonprefix-last",
    whichString: "last with same prefix",
    fn: (files, current, length, settings) => indexOfPrevNextWithCommonPrefix(files, current, length, settings, true)
  }
];

// src/sorting_methods.ts
var SORTING_METHODS = [
  {
    id: "alpha",
    byString: "name",
    fn: (a, b) => a.basename.localeCompare(b.basename)
  },
  {
    id: "ctime",
    byString: "creation date",
    fn: (a, b) => a.stat.ctime - b.stat.ctime
  },
  {
    id: "mtime",
    byString: "modification date",
    fn: (a, b) => a.stat.mtime - b.stat.mtime
  }
];

// src/settings_tab.ts
var import_obsidian = require("obsidian");
var NavigatorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Today date format").setDesc("Will look for this date format in the title when navigating Today notes").addMomentFormat((mfmt) => mfmt.setDefaultFormat(DEFAULT_SETTINGS.todayDateFormat).setValue(this.plugin.settings.todayDateFormat).onChange(async (value) => {
      this.plugin.settings.todayDateFormat = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Notes with same prefix" });
    new import_obsidian.Setting(containerEl).setName("Separators").setDesc("Characters used to tokenize the common prefix (if empty, looks for all characters)").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.commonPrefixSeparators).setValue(this.plugin.settings.commonPrefixSeparators).onChange(async (value) => {
      this.plugin.settings.commonPrefixSeparators = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Extend search").setDesc("Whether to look for the previous/next note if at the first/last note already").addToggle((toggle) => toggle.setValue(this.plugin.settings.commonPrefixExtendSearch).onChange(async (value) => {
      this.plugin.settings.commonPrefixExtendSearch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Use the same extension").setDesc("Whether to ignore files with different extensions").addToggle((toggle) => toggle.setValue(this.plugin.settings.useSameExtension).onChange(async (value) => {
      this.plugin.settings.useSameExtension = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Last/New commands" });
    containerEl.createEl("p", { text: "You can define commands that will open the last or a new note following a particular pattern." });
    containerEl.createEl("p", { text: "The character '#' will be replaced by today's date" });
    containerEl.createEl("p", { text: "You will need to restart Obsidian before you can use the commands defined here." });
    let patternDiv = containerEl.createDiv();
    for (let pattern of this.plugin.settings.commandPatterns) {
      this.createCommandPatternSetting(patternDiv, pattern);
    }
    new import_obsidian.Setting(containerEl).addButton(
      (button) => button.setButtonText("Add pattern").onClick(async () => {
        const pattern = {
          id: crypto.randomUUID(),
          name: "New pattern",
          pattern: "Untitled #"
        };
        this.plugin.settings.commandPatterns.push(pattern);
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
  createCommandPatternSetting(containerEl, pattern) {
    let s = new import_obsidian.Setting(containerEl);
    s.setName("Pattern");
    s.setDesc("Example: " + commandPatternExpand(pattern.pattern, this.plugin.settings));
    s.addText(
      (text) => text.setPlaceholder("Name").setValue(pattern.name).onChange(async (value) => {
        pattern.name = value;
        await this.plugin.saveSettings();
      })
    );
    s.addText(
      (text) => text.setPlaceholder("Pattern").setValue(pattern.pattern).onChange(async (value) => {
        pattern.pattern = value;
        await this.plugin.saveSettings();
        s.setDesc("Example: " + commandPatternExpand(pattern.pattern, this.plugin.settings));
      })
    );
    s.addExtraButton(
      (button) => button.setIcon("trash").onClick(async () => {
        this.plugin.settings.commandPatterns.remove(pattern);
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
};

// src/main.ts
var NavigatorPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new NavigatorSettingTab(this.app, this));
    SORTING_METHODS.forEach((sortingMethod) => {
      MOVEMENT_METHODS.forEach((movementMethod) => {
        this.addCommand({
          id: "navigator-folder-" + movementMethod.id + "-" + sortingMethod.id,
          name: "By " + sortingMethod.byString + ": Open " + movementMethod.whichString + " in folder",
          checkCallback: (checking) => this.cmdOpenNoteInFolder(checking, sortingMethod.fn, movementMethod.fn)
        });
      });
    });
    for (let pattern of this.settings.commandPatterns) {
      this.addCommand({
        id: "navigator-lastnew-" + pattern.id,
        name: "Last/New " + pattern.name,
        callback: () => {
          let p = commandPatternExpand(pattern.pattern, this.settings);
          this.openOrCreateFile(p);
        }
      });
      this.addCommand({
        id: "navigator-last-" + pattern.id,
        name: "Last " + pattern.name,
        callback: () => {
          this.cmdOpenLastFileWithPattern(pattern);
        }
      });
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  cmdOpenNoteInFolder(checking, sortingFn, movementFn) {
    let thisFile = this.app.workspace.getActiveFile();
    if (!thisFile)
      return false;
    let folder = thisFile.parent;
    if (!folder)
      return false;
    if (!checking) {
      let files = folder.children.filter((file) => {
        if (!(file instanceof import_obsidian2.TFile))
          return false;
        let f = file;
        if (this.settings.useSameExtension && f.extension !== (thisFile == null ? void 0 : thisFile.extension))
          return false;
        return true;
      });
      files = files.sort(sortingFn);
      let idx = files.indexOf(thisFile);
      idx = movementFn(files, idx, files.length, this.settings);
      if (idx < 0 || idx >= files.length)
        return true;
      this.app.workspace.openLinkText(files[idx].path, "", false);
    }
    return true;
  }
  cmdOpenLastFileWithPattern(pattern) {
    let files = this.app.vault.getFiles();
    let filesWithPattern = filesWithCommandPattern(files, pattern.pattern, this.settings.todayDateFormat);
    if (!filesWithPattern.length)
      return;
    filesWithPattern = filesWithPattern.sort((a, b) => a.basename.localeCompare(b.basename));
    this.app.workspace.openLinkText(filesWithPattern[0].path, "", false);
  }
  async openOrCreateFile(path) {
    this.app.workspace.openLinkText(path, "", false);
  }
};
